# A continuación se presentan los archivos creados en el package "controllers" del proyecto "orders-api".

## 1. Crear clase "CategoriaController.java" en el package "controllers."

**Código de clase:**

```
package com.devsoft.orders_api.controllers;

import com.devsoft.orders_api.dto.CategoriaDTO;
import com.devsoft.orders_api.dto.MenuDTO;
import com.devsoft.orders_api.entities.Categoria;
import com.devsoft.orders_api.interfaces.ICategoriaService;
import org.apache.coyote.Response;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.dao.DataAccessException;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Objects;

@RestController // Anotación que indica que esta clase es un controlador REST
@CrossOrigin // Permite solicitudes desde otros dominios (CORS)/cruzadas
@RequestMapping("/api") // Define la ruta base para las solicitudes a este controlador
public class CategoriaController { // Controlador para manejar las operaciones relacionadas con las categorías

    //Anotación de inyección de dependencias
    @Autowired
    private ICategoriaService categoriaService; // Inyecta el servicio de categorías

    //Endpoint para obtener todas las categorías
    //Ruta para obtener todas las categorías
    @GetMapping("/categorias")
    public ResponseEntity<?> getAll() {
        List<CategoriaDTO> categoriaDTOList = categoriaService.findAll();
        return ResponseEntity.ok(categoriaDTOList);
    }

    // Endpoint para obtener un MenuDTO por su ID
    @GetMapping("/categorias/{id}") // Ruta para obtener una categoría por su ID
    public ResponseEntity<?> getById(@PathVariable Long id) {
        CategoriaDTO categoriaDTO = null;
        Map<String, Object> response = new HashMap<>();
        try {
            categoriaDTO = categoriaService.findById(id);
        } catch (DataAccessException e) {
            response.put("message", "Error al realizar la consulta a la base de datos");
            response.put("error", e.getMessage());
            return new ResponseEntity<Map<String, Object>>(response, HttpStatus.INTERNAL_SERVER_ERROR);
        }
        if (categoriaDTO == null) {
            response.put("message", "La categoria con ID: "
                    .concat(id.toString().concat(" no existe en la base de datos")));
            return new ResponseEntity<Map<String, Object>>(response, HttpStatus.NOT_FOUND);
        }
        return new ResponseEntity<CategoriaDTO>(categoriaDTO, HttpStatus.OK);
    }

    // Método guardar una categoría por su ID
    @PostMapping("/categorias")
    public ResponseEntity<?> save(@RequestBody CategoriaDTO dto) {
        CategoriaDTO catPersisted = new CategoriaDTO();
        Map<String, Object> response = new HashMap<>();
        try {
            // Validar que el nombre de la categoría no sea nulo o vacío
            CategoriaDTO catExiste = categoriaService.findByNombre(dto.getNombre());
            if (catExiste != null && dto.getId() == null) {
                response.put("message", "Ya existe una categoria con este nombre, digite otro");
                return new ResponseEntity<Map<String, Object>>(response, HttpStatus.CONFLICT); // Retorna una respuesta con el estado 409 (CONFLICT) si ya existe una categoría con el mismo nombre
            }
            catPersisted = categoriaService.save(dto);
            response.put("message", "Categoria guardada correctamente");
            response.put("categoria", catPersisted);
            return new ResponseEntity<Map<String, Object>>(response, HttpStatus.CREATED); // Retorna una respuesta con el estado 201 (CREATED) y el objeto guardado
        } catch (DataAccessException e) {
            response.put("message", "Error al insertar el registro, intente nuevamente");
            response.put("error", e.getMessage());
            return new ResponseEntity<Map<String, Object>>(response, HttpStatus.INTERNAL_SERVER_ERROR); // Retorna una respuesta con el estado 500 (INTERNAL_SERVER_ERROR) y el mensaje de error
        }
    }

    //endpoint para actualizar una categoría por su ID
    @PutMapping("/categorias/{id}") // Ruta para actualizar una categoría por su ID
    public ResponseEntity<?> update(@PathVariable Long id, @RequestBody CategoriaDTO dto) {
        CategoriaDTO catActual = categoriaService.findById(id);
        CategoriaDTO catUpdated = null;
        Map<String, Object> response = new HashMap<>();
        if (catActual == null) {
            response.put("message", "No existe una categoria con el ID: "
                    .concat(id.toString().concat("no existe en la base de datos")));
            return new ResponseEntity<Map<String, Object>>(response, HttpStatus.NOT_FOUND); // Retorna una respuesta con el estado 404 (NOT FOUND) si no se encuentra la categoría
        }
        try {
            CategoriaDTO catExiste = categoriaService.findByNombre(dto.getNombre());
            if (catExiste != null && !Objects.requireNonNull(catExiste).getId().equals(id)) {
                response.put("message", "Ya existe una categoria con este nombre, digite otro");
                return new ResponseEntity<Map<String, Object>>(response, HttpStatus.CONFLICT); // Retorna una respuesta con el estado 409 (CONFLICT) si ya existe una categoría con el mismo nombre
            }
            catActual.setNombre(dto.getNombre());
            catUpdated = categoriaService.save(catActual);
            response.put("message", "Categoria actualizada correctamente");
            response.put("categoria", catUpdated);
            return new ResponseEntity<Map<String, Object>>(response, HttpStatus.OK); // Retorna
        } catch (DataAccessException e) {
            response.put("message", "Error al actualizar el registro, intente nuevamente");
            response.put("error", e.getMessage());
            return new ResponseEntity<Map<String, Object>>(response, HttpStatus.INTERNAL_SERVER_ERROR); // Retorna una respuesta con el estado 500 (INTERNAL_SERVER_ERROR) y el mensaje de error
        }
    }

    //endpoint para eliminar una categoría por su ID
    @DeleteMapping("/categorias/{id}") // Ruta para eliminar una categoría por su ID
    public ResponseEntity<?> delete(@PathVariable Long id) {
        Map<String, Object> response = new HashMap<>();
        CategoriaDTO catActual = categoriaService.findById(id);
        if (catActual == null) {
            response.put("message", "No existe una categoria con el ID: "
                    .concat(id.toString().concat("no existe en la base de datos")));
            return new ResponseEntity<Map<String, Object>>(response, HttpStatus.NOT_FOUND); // Retorna una respuesta con el estado 404 (NOT FOUND) si no se encuentra la categoría
        }
        try {
            categoriaService.delete(id);
        }catch (DataAccessException e){
            response.put("message", "Error al eliminar el registro, intente nuevamente");
            return new ResponseEntity<Map<String, Object>>(response, HttpStatus.INTERNAL_SERVER_ERROR); // Retorna una respuesta con el estado 500 (INTERNAL_SERVER_ERROR) y el mensaje de error
        }
        response.put("message", "Categoria eliminada correctamente");
        return new ResponseEntity<Map<String, Object>>(response, HttpStatus.OK); // Retorna una respuesta con el estado 200 (OK) y el mensaje de éxito
    }
}
```

## 2. Crear clase "MenuController.java" en el package "controllers."

**Código de clase:**

```
package com.devsoft.orders_api.controllers;

import com.devsoft.orders_api.dto.MenuDTO;
import com.devsoft.orders_api.interfaces.IMenuService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.dao.DataAccessException;
import org.springframework.dao.DataIntegrityViolationException;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;
import org.springframework.web.multipart.MultipartFile;

import java.io.IOException;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

@RestController // Anotación que indica que esta clase es un controlador REST
@CrossOrigin // Permite solicitudes desde otros dominios (CORS)/cruzadas
@RequestMapping("/api") // Define la ruta base para las solicitudes a este controlador
public class MenuController {
    @Autowired
    private IMenuService menuService;

    //Endpoint para obtener todas las categorías
    //Ruta para obtener todas las categorías
    @GetMapping("/menus")
    public ResponseEntity<?> getAll() {
        List<MenuDTO> menuList = menuService.findAll();
        return ResponseEntity.ok(menuList);
    }

    // Endpoint para obtener un MenuDTO por su ID
    @GetMapping("/menus/{id}") // Ruta para obtener una categoría por su ID
    public ResponseEntity<?> getById(@PathVariable Long id) {
        MenuDTO menuDTO = null;
        Map<String, Object> response = new HashMap<>();
        try {
            menuDTO = menuService.findById(id);
        } catch (DataAccessException e) {
            response.put("message", "Error al realizar la consulta a la base de datos");
            response.put("error", e.getMessage());
            return new ResponseEntity<Map<String, Object>>(response, HttpStatus.INTERNAL_SERVER_ERROR);
        }
        if (menuDTO == null) {
            response.put("message", "El menú con ID: "
                    .concat(id.toString().concat(" no existe en la base de datos")));
            return new ResponseEntity<Map<String, Object>>(response, HttpStatus.NOT_FOUND);
        }
        return new ResponseEntity<MenuDTO>(menuDTO, HttpStatus.OK);
    }

    // Método guardar un menú
    @PostMapping("/menus")
    public ResponseEntity<?> save(@RequestPart MenuDTO dto,
                                  @RequestPart(value = "imagen", required = false) MultipartFile imageFile) {
        MenuDTO menuPersisted = new MenuDTO();
        Map<String, Object> response = new HashMap<>();

        try {
            MenuDTO menuExiste = menuService.findByNombre(dto.getNombre());
            if (menuExiste != null && dto.getId() == null) {
                response.put("message", "Ya existe un menú o producto con este nombre, digite otro");
                return new ResponseEntity<Map<String, Object>>(response, HttpStatus.BAD_REQUEST);
            }
            menuPersisted = menuService.save(dto, imageFile);
            response.put("message", "Menú insertado correctamente...!");
            response.put("menu", menuPersisted);
            return new ResponseEntity<Map<String, Object>>(response, HttpStatus.CREATED);

        } catch (DataAccessException e) {
            response.put("message", "Error al insertar el registro, intente nuevamente");
            response.put("error", e.getMessage());
            return new ResponseEntity<Map<String, Object>>(response, HttpStatus.INTERNAL_SERVER_ERROR); // Retorna una respuesta con el estado 500 (INTERNAL_SERVER_ERROR) y el mensaje de error
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }

    //endpoint para actualizar un menú por su ID
    @PutMapping("/menus/{id}")
    public ResponseEntity<?> update(@PathVariable Long id,
                                    @RequestPart MenuDTO dto, // Usamos @RequestPart para recibir el DTO y la imagen
                                    // Se usa MultipartFile para recibir archivos
                                    @RequestPart(value = "imagen", required = false) MultipartFile imageFile) {
        Map<String, Object> response = new HashMap<>(); // Mapa para almacenar la respuesta
        MenuDTO menuActual = menuService.findById(id); // Obtenemos el menú actual por ID
        MenuDTO menuActualizado; // Variable para almacenar el menú actualizado

        // Verificamos si el menú actual es nulo (no existe en la base de datos)
        if (menuActual == null) {
            response.put("message", "No existe un menú con el ID: " + id + " en la base de datos");
            return new ResponseEntity<>(response, HttpStatus.NOT_FOUND); // Retorna una respuesta con el estado 404 (NOT FOUND) si no se encuentra el menú
        }

        // Verificamos si ya existe un menú con el mismo nombre
        try {
            MenuDTO menuExiste = menuService.findByNombre(dto.getNombre());
            if (menuExiste != null && !menuExiste.getId().equals(id)) { // Verificamos si el menú existe y si su ID es diferente al que estamos actualizando
                response.put("message", "Ya existe un menú o producto con este nombre, digite otro");
                return new ResponseEntity<>(response, HttpStatus.CONFLICT); // Retorna una respuesta con el estado 409 (CONFLICT) si ya existe un menú con el mismo nombre
            }
            dto.setId(id); // Establecemos el ID del DTO para que se actualice el menú existente
            menuActualizado = menuService.save(dto, imageFile); // Llamamos al servicio para guardar el menú actualizado
            response.put("message", "Menú actualizado correctamente");
            response.put("menu", menuActualizado); // Agregamos el menú actualizado a la respuesta
            return new ResponseEntity<>(response, HttpStatus.OK); // Retorna una respuesta con el estado 200 (OK) y el menú actualizado

            // Si se produce una excepción al acceder a la base de datos o al procesar la imagen, capturamos la excepción y retornamos un mensaje de error
        } catch (DataAccessException | IOException e) {
            response.put("message", "Error al actualizar el registro, intente nuevamente");
            response.put("error", e.getMessage());
            return new ResponseEntity<>(response, HttpStatus.INTERNAL_SERVER_ERROR);
        }
    }

    @DeleteMapping("/menus/{id}")
    public ResponseEntity<?> delete(@PathVariable Long id) {
        Map<String, Object> response = new HashMap<>();
        MenuDTO menuActual = menuService.findById(id);
        if (menuActual == null) {
            response.put("message", "No se puede eliminar el menú o producto con ID: "
                    .concat(id.toString().concat(" ya que no existe en la base de datos")));
            return new ResponseEntity<Map<String, Object>>(response, HttpStatus.NOT_FOUND);
        }
        try {
            menuService.delete(id);
            response.put("message", "Menú eliminado correctamente");
            return new ResponseEntity<Map<String, Object>>(response, HttpStatus.OK);
        } catch (DataIntegrityViolationException e) {
            response.put("message", "No se puede eliminar el menú " + menuActual.getNombre() + ", porque está en uso");
            response.put("error", e.getMessage());
            return new ResponseEntity<>(response, HttpStatus.CONFLICT);
        } catch(DataAccessException e) {
            response.put("message", "No se puede eliminar el menú, ya que tiene ordenes asociadas");
            return new ResponseEntity<Map<String, Object>>(response, HttpStatus.INTERNAL_SERVER_ERROR);
        }
    }
}

```

## 3. Crear clase "OrdenController.java" en el package "controllers."

**Código de clase:**

```
package com.devsoft.orders_api.controllers;

import com.devsoft.orders_api.dto.CategoriaDTO;
import com.devsoft.orders_api.dto.OrdenDTO;
import com.devsoft.orders_api.entities.Orden;
import com.devsoft.orders_api.interfaces.IOrdenService;
import com.devsoft.orders_api.utils.EstadoOrden;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.dao.DataAccessException;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Objects;

@RestController
@CrossOrigin
@RequestMapping("/api")
public class OrdenController {
    @Autowired
    private IOrdenService ordenService;

    //Endpoint para listar todas las órdenes
    @GetMapping("/ordenes")
    public ResponseEntity<?> getAll() {
        List<OrdenDTO> ordenes = ordenService.findAll();
        return ResponseEntity.ok(ordenes);
    }

    //Endpoint para listar órdenes por estado
    @GetMapping("/ordenes/estado/{estado}")
    public ResponseEntity<?> getAllEstado(@PathVariable EstadoOrden estado) {
        List<OrdenDTO> lista = ordenService.findByEstado(estado);
        return ResponseEntity.ok(lista);
    }

    //Endpoint para obtener una orden por su ID
    @GetMapping("/ordenes/{id}") // Ruta para obtener una categoría por su ID
    public ResponseEntity<?> getById(@PathVariable Long id) {
        Map<String, Object> response = new HashMap<>();
        try {
            OrdenDTO dto = ordenService.findById(id);
            if (dto == null) {
                response.put("message", "La orden con ID: "
                        .concat(id.toString()
                                .concat(" no existe en la base de datos")));
                return new ResponseEntity<>(response, HttpStatus.NOT_FOUND);
            }
            return new ResponseEntity<>(dto, HttpStatus.OK);
        } catch (DataAccessException e) {
            response.put("message", "Error al realizar la consulta a la base de datos");
            response.put("error", e.getMessage());
            return new ResponseEntity<Map<String, Object>>(response, HttpStatus.INTERNAL_SERVER_ERROR);
        }
    }

    //Endpoint para crear una nueva orden
    @PostMapping("/ordenes")
    public ResponseEntity<?> create(@RequestBody OrdenDTO dto) {
        Map<String, Object> response = new HashMap<>();
        try {
            OrdenDTO dtoCreated = ordenService.registerOrUpdate(dto);
            if (dtoCreated == null) {
                response.put("message", "No se pudo crear la orden, verifique los datos ingresados");
                return new ResponseEntity<>(response, HttpStatus.BAD_REQUEST);
            }
            response.put("message", "La orden ha sido creada con éxito");
            response.put("orden", dtoCreated);
            return new ResponseEntity<>(response, HttpStatus.CREATED);
        } catch (DataAccessException e) {
            response.put("message", "Error al realizar la órden a la base de datos");
            response.put("error", e.getMessage());
            return new ResponseEntity<>(response, HttpStatus.INTERNAL_SERVER_ERROR);
        }
    }

    //Endpoint para actualizar una orden
    @PutMapping("/ordenes/{id}") // Ruta para actualizar una categoría por su ID
    public ResponseEntity<?> update(@PathVariable Long id,
                                    @RequestBody OrdenDTO dto) {
        OrdenDTO ordenActual = ordenService.findById(id);
        Map<String, Object> response = new HashMap<>();
        if (ordenActual == null) {
            response.put("message", "No se puede editar la órden con el ID: "
                    .concat(id.toString().concat("no existe en la base de datos")));
            return new ResponseEntity<Map<String, Object>>(response, HttpStatus.NOT_FOUND);
        }
        try {
            ordenActual.setClienteDTO(dto.getClienteDTO());
            ordenActual.setMesaDTO(dto.getMesaDTO());
            ordenActual.setUsuarioDTO(dto.getUsuarioDTO());
            ordenActual.setTotal(dto.getTotal());
            ordenActual.setDetalle(dto.getDetalle());
            OrdenDTO dtoUptated = ordenService.registerOrUpdate(ordenActual);
            if (dtoUptated == null) {
                response.put("message", "No se pudo actualizar la orden, verifique los datos ingresados");
                return new ResponseEntity<>(response, HttpStatus.BAD_REQUEST);
            }
            response.put("message", "La orden ha sido actualizada con éxito");
            response.put("orden", dtoUptated);
            return new ResponseEntity<>(response, HttpStatus.ACCEPTED);
        } catch (DataAccessException e) {
            response.put("message", "Error al actualizar el registro, intente nuevamente");
            response.put("error", e.getMessage());
            return new ResponseEntity<Map<String, Object>>(response, HttpStatus.INTERNAL_SERVER_ERROR); // Retorna una respuesta con el estado 500 (INTERNAL_SERVER_ERROR) y el mensaje de error
        }
    }

    //Endpoint para cambiar el estado de una orden
    @PutMapping("/ordenes/cambiar-estado")
    public ResponseEntity<?> changeState(@RequestBody OrdenDTO dto) {
        Map<String, Object> response = new HashMap<>();
        try {
            OrdenDTO ordenUpdated = ordenService.changeState(dto);
            if (ordenUpdated == null) {
                response.put("message", "No se pudo cambiar el estado de la orden, verifique los datos ingresados");
                return new ResponseEntity<>(response, HttpStatus.BAD_REQUEST);
            }
            response.put("message", "El estado de la orden ha cambiado a: " + ordenUpdated.getEstado());
            response.put("orden", ordenUpdated);
            return new ResponseEntity<>(response, HttpStatus.ACCEPTED);
        } catch (DataAccessException e) {
            response.put("message", "Error al cambiar el estado de la orden");
            response.put("error", e.getMessage());
            return new ResponseEntity<>(response, HttpStatus.INTERNAL_SERVER_ERROR);
        }
    }

    //Endpoint para anular una orden
    @PutMapping("/ordenes/anular/{id}")
    public ResponseEntity<?> anularOrden (@PathVariable Long id) {
        Map<String, Object> response = new HashMap<>();
        OrdenDTO ordenActual = ordenService.findById(id);
        if (ordenActual == null) {
            response.put("message", "No se puede anular la orden con el ID: "
                    .concat(id.toString().concat(" no existe en la base de datos")));
            return new ResponseEntity<>(response, HttpStatus.NOT_FOUND);
        }
        try {
            ordenService.anular(id);
            response.put("message", "La orden ha sido anulada con éxito");
            return new ResponseEntity<>(response, HttpStatus.OK);
        } catch (DataAccessException e) {
            response.put("message", "Error al anular la orden");
            response.put("error", e.getMessage());
            return new ResponseEntity<>(response, HttpStatus.INTERNAL_SERVER_ERROR);
        }
    }
}
```
